--------------------------------------------------------------------
ğŸ”¥ PALINDROME GENERATOR â€” FULL YUVRAJ-STYLE EXPLANATION
--------------------------------------------------------------------

VIDEO LINK FOR EXPLANATION - https://youtu.be/j_cFgoSJqDQ?si=6DRpghuIdYObP4lH&t=876

ğŸ“Œ WHAT IS THIS ABOUT?
We want to *generate* palindromes directly instead of brute-forcing and checking every number.

Why?
Because if we just loop from 1 to infinity and check if each number is a palindrome â†’ it's slow.
Instead, we will build palindromes mathematically and in sorted order.

--------------------------------------------------------------------
âš¡ THE MAIN OBSERVATION:
A palindrome is fully defined by its first half.
Example:
    1221 â†’ first half = "12" â†’ reverse = "21" â†’ append to "12" â†’ 1221
    12321 â†’ first half = "123" â†’ reverse = "321" â†’ remove the first digit "3" from reverse â†’ append â†’ 12321

So:
- If length is EVEN â†’ copy the first half, then append the full reverse of it.
- If length is ODD â†’ copy the first half, then append reverse of it *excluding* the first character (middle digit).

--------------------------------------------------------------------
ğŸ“Œ STEP 1 â€” LENGTH DRIVEN APPROACH
We think in terms of "length L" of the palindrome, not the value.

Example:
L = 1  â†’ {0, 1, 2, 3, ... , 9}
L = 2  â†’ {11, 22, 33, ... , 99}
L = 3  â†’ {101, 111, 121, ... , 999}
L = 4  â†’ {1001, 1111, 1221, ... , 9999}
...

--------------------------------------------------------------------
ğŸ“Œ STEP 2 â€” HOW TO CALCULATE RANGE OF HALF
Let:
    halfLen = (L + 1) / 2    // middle included in odd length
    startHalf = 10^(halfLen - 1)  // to avoid leading zero
    endHalf   = 10^halfLen - 1

Example: L = 4 (even)
    halfLen = (4+1)/2 = 2
    startHalf = 10^(2-1) = 10
    endHalf   = 99
Possible halves: 10 â†’ 99

Example: L = 5 (odd)
    halfLen = (5+1)/2 = 3
    startHalf = 100
    endHalf   = 999
Possible halves: 100 â†’ 999

--------------------------------------------------------------------
ğŸ“Œ STEP 3 â€” GENERATION LOGIC
For each half in [startHalf, endHalf]:
    Convert half to string â†’ reverse it.
    If L is EVEN:
        palindrome = half + reverse(half)
    If L is ODD:
        palindrome = half + reverse(half)[1:] // skip the first char of reverse

This ensures:
- No leading zeros
- Sorted order
- O(1) check if palindrome â†’ because we made it palindrome

--------------------------------------------------------------------
ğŸ“Œ DRY RUN EXAMPLES
Case 1: L = 4, half = 12
    rev = 21
    palindrome = "12" + "21" = 1221 âœ…

Case 2: L = 5, half = 123
    rev = 321
    palindrome = "123" + "21" = 12321 âœ…

Case 3: L = 3, half = 10
    rev = 01
    palindrome = "10" + "0" = 1001 âŒ invalid for L=3 because half range chosen avoids this (start = 10 means no leading zero problem in half)

--------------------------------------------------------------------
ğŸ“Œ EDGE CASES:
1. Single digit (L=1) â†’ halfLen=1 â†’ start=1 â†’ palindromes {1,2,...,9}
2. Large numbers (up to 10^15) â†’ we never generate palindromes longer than needed.
3. Leading zero in reverse half â†’ not an issue because we never start half with 0.

--------------------------------------------------------------------
ğŸ“Œ WHY THIS WORKS â€” MATH PROOF:
Number of palindromes of length L:
    If L is EVEN: count = 9 * 10^(L/2 - 1)
    If L is ODD:  count = 9 * 10^((L-1)/2)
This is exactly the number of possible halves without leading zero.
Thus, generating halves in ascending order â†’ palindromes in ascending order.

--------------------------------------------------------------------
ğŸ“Œ TIME COMPLEXITY:
Let M = target palindrome length
    Generating all palindromes of length L takes:
        O(10^(L/2)) iterations.
    Each iteration:
        - Reverse string â†’ O(L)
Total:
    O(10^(L/2) * L) for each length L.

Space Complexity:
    O(L) for temporary strings.

--------------------------------------------------------------------
ğŸ“Œ PSEUDO CODE:
for L = 1 to âˆ:
    halfLen = (L + 1) / 2
    start = 10^(halfLen - 1)
    end = 10^halfLen - 1

    for half in start..end:
        s = toString(half)
        rev = reverse(s)
        if L is odd:
            pal = s + rev.substring(1)
        else:
            pal = s + rev
        process pal

--------------------------------------------------------------------
ğŸ“Œ RELATION TO OUR kMirror CODE:
In kMirror:
    - L is the length of palindrome in base 10.
    - We generate palindromes using the same method above.
    - Then we convert to base-k and check if THAT is also palindrome.

--------------------------------------------------------------------
